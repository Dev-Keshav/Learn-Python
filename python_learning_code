#Started with python

#addition of two numbers
"""
a= 3+4
print(a)
"""

#Subtraction of two numbers
"""
a= 3-8
print(a)
"""

#Multyplication of two numbers
"""
a= 3*8
print(a)
"""
#finding power
"""
a= 2**3
print(a)
"""
#Division
"""
a= 4/2
print(a)
"""

#----float Division---
"""
a= 4//2
print(a)
"""
#Multyple mathmatic opertion
"""
#a= 3+5-2
a= (3+5)*2
print(a)
"""

#Modular %

#a= 10//3
"""
a= 10%3   #Modular gives you the reminder part of division
print(a)
"""


#----------------------------String----------------------------------------

"""
print('pintoo')
"""
#-------------------
"""
a= 'pintoo'
print(a)
"""
#--------------------

#print("pintoo's laptop")

#print('pintoo "laptop"')

"""
print('pintoo\'s "laptop"') # \ means skip the special meaning of syntax
        #or
print("pintoo \"laptop")
"""

#Concatinate two strings or adding two string
"""
a= "pintoo"
b= " kumar"
c= a+b
print(c)
"""
#---------------
"""
a= "pintoo" + " kumar"
print(a)
"""
#---------------
#print string multyple times by mltylping
"""
a= "pintoo " * 10
print(a)
"""
#--------------------
"""
print("c:\computer\navin")
print("My \name is PinTwo") #In python \n has a special meaning which means after \n it will start printing from new line
                            #to avoid printing from new line simply put r called raw string before printing line
"""
#print(r"My \name is PinTwo")



#-------------------------variables-----------------------
#x= 2
#Variable is a container where you put the values | and name of the container is x

"""
x= 2
y= x+5
print(y)
"""
#-----------

#String | Variables
"""
first_name="pintoo"
name= first_name + " kumar"
print(name)
"""
#------------------------------------
"""
first_name="pintoo"
last_name= " kumar"
name= first_name + last_name
print(name)
"""
#-------------------
#Now let's fetch the strings from array

#name= "PinTwo"
"""
print(name[1]) #If i start from positve number it will print from left side
print(name[-1]) #If i start from negative number it will print from right side
"""
"""
print(name[0:3])
print(name[0:])
print(name[:3])
"""

#naam= print(name[0:]+" kumar")

#----------------------------------list in python------------------------------------------------------------------
"""
num= [54,64,32,65,45,87,23]
print(num)
print(num[1])
"""
#-----------
"""
naam= ["pintoo", "satyam", "keshav", "kush","shivam"]
print(naam)
print(naam[1])
"""
#-----------------------
"""
num= [54,64,32,65,45,87,23]
naam= ["pintoo", "satyam", "keshav", "kush","shivam"]

print(num,naam)
"""
"""
num= [54,64,32,65,45,87,23]
#num.append(11)      #It will add values in last
#num.insert(0,11)    #it will insert value on index number 0
#num.remove(54)  #it will remove that given values
#num.pop(0)      #it will remove the value of given index number
#del num[0:3]    #It will delete multiple value which is specify in index value
#num.extend([2,74,3,8,9])   #it will add multiple values
#print(min(num))  #it will gives you minimum value from list
#print(max(num))   # it will gives you maximum value from list
#print(sum(num))   # it will gives you sum list
#num.sort()   #it will give you values in sorted format
#num[0]= 55   #It wil change the value of given index value
print(num)
"""
#-------------------------------------Tuple in python--------------------------------------------
#Tuple is Unmutable it means we can't change the values like List
"""
tups= (22,43,67,32,98,54,36,22)
#print(tups[1])
print(tups)
"""

#--------------------------------------Set in python-----------------------------------------
#set is a colection of unique values, it means in a set their should not be repeated value otherwise it will not print
#set do not follow  sequence so it does not support index function
"""
se= {23,56,79,34,32,90,78}
print(se)
"""
#-----------
"""
se= {23,23,56,79,34,32,90,78}
#se.remove(90)  #It will remove the given value from set
print(se)
"""

#------------------------------------Dictionery in python-------------------------------------------------
"""
data= {1:"pintoo", 2:"satyam", 3:"kush", 4:"luv", 5:"shivam"}
print(data[1])
#print(data.get(6))
print(data)
"""
#-----------------
"""
name= ["pintoo", "styam", "kush", "shivam"]
program= ["python","css","java", "html"]
dicts= dict(zip(name,program))

#print(dicts)
print(dicts["pintoo"])

#dicts["tarun"]= "js" #this line will add more in the dictioney
#del dicts["tarun"]   #this will delete from dictionery

print(dicts)
"""

#-------------Dictionery in dictionery-------------------------
"""
data= {"pintoo":"yadav","satyam":'tiwari',"nikhil":"singh","subject":["hindi","english","science","math"],

       "city":{"pintoo":"pitampura","nikhil":"begumpur","satyam":"saraswati vihar"}}

print(data)
print(data["pintoo"])

print(data["subject"])
print(data["subject"][1])

print(data["city"])
print(data["city"]["satyam"])
"""

#--------------------------More on variables------------------------------
"""
num= 4
naam= "pintwo"

print(id(num))
print(id(naam))
"""
#-------------
"""
a= 5
#b=a
b=6
m= 5

print(id(a))
print(id(b))
print(id(m))
"""

#--------------------------------------------Data types in python--------------------------------------------------

#None
#Numeric
#String
#List
#Tuple
#Set
#Range
#Dictionery

#-----------------------------------None data type---------------------------

#When you have variables which have not assign any value is called None

#---------------------------Numeric data type-------------------------------

#int
#float
#complex
#bool
"""
a= 8
print(type(a))   #int

b= 4.2
print(type(b))   #float

c= 3+5j
print(type(c))   #comlex

d= 5<8          #bool  (boolean data type is either True or False. In Python, boolean variables are defined by the True and False keywords)
print(type(d))
"""

#------convert one data types to another

#int to float

"""
a= 8
b= float(a)
print(b)
print(type(b))
"""
#float to int
"""
a= 8.3
b= int(a)
print(b)
print(type(b))
"""
#int to bool
"""
a= 8
b= bool(a)
print(b)
print(type(b))
"""
#int to complex
"""
a= 8
b= 3
c= complex(a,b)
print(c)
print(type(c))
"""
#-------------------------------------[list], (tuple), {set}, "string" data type-------------------------------------
"""
lst= [34,67,12,63,25,29,54]
print(type(lst))  #list

tpl= (34,67,12,63,25,29,54)
print(type(tpl))   #tuple

sat= {34,67,12,63,25,29,54}
print(type(sat))   #set

str= "pintoo"
print(type(str))
"""
#----------------------------------range data type---------------------------------------
"""
x= list(range(10))
print(x)
"""
"""
x= list(range(1,10,2))
print(x)
"""

#----------------------------------Dictionery data type------------------------------------------------------
"""
data= {"pintoo":"realme c1", "satyam":"jio phone", "kush":"samsung", "shivm":"apple"}

print(data)
print(data.keys())
print(data.values())
print(data["pintoo"])
"""
#-----------------------------------operators in python----------------------------------------------
#Arithmetic operators
#Assignment operators
#Relational operators
#Logical operators
#Unary operator

#-----------------------------------------Arithmetic operators-------------------------------------
"""
a= 3+4          #Addition
print(a)
"""
"""
a= 3-8     #Subtracion
print(a)
"""
"""
a= 3*8   #Multiplication
print(a)
"""

#------------------------------------------Assignment operators-------------------------------------------
#simply means assigning the values

"""
a= 5
b,c= 3,7

print(a)
print(b)
print(c)
"""
#-------
"""
a=5
b= 7
c= a+b
print(c)
"""
#--------------------------------------------------Unary operators--------------------------------------------
#(-)
"""
n= 7
n= -n
print(n)
"""

#---------------------------------------------Relational operators-----------------------------------------------

"""
a= 5
b= 6

#x= a<b      #a is less then b
#x= a>b       #a is greater then b
#x= a==b     #a is equal to b
#x= a<=b     #a is less then and equal to b
#x= a>=b     #a is greater then and equal to b
#x= a!=b     #a is not equal to b 

print(x)
"""

#---------------------------------------Logical Operators------------------------------------------------------------
"""
a= 5
b= 6
#x= a<10 and b<15  #and operator will print true if both the condition are true
#x= a<10 and b<4   #and operator will print false if one codition is true or another condition is false
#x= a<10 or b<15
x= a<10 or b<b
print(x)
"""
"""
a= True
a= not a
print(a)
"""

#---------------------------------------------Number System Conversion in python----------------------------------------

#Decialmal > Base 10 > 0-9 : 0-1-2-3-4-5-6-7-8-9
#Binary > Base 2 > 0-1 : 0-1
#Octal > Base 8 > 0-7: 0-1-2-3-4-5-6-7
#HexaDecimal > Base 16 > 0-9 a-f: 0-1-2-3-4-5-6-7-8-9 a-b-c-d-e-f


#convert decimal number to binary format: 25 > 0b11001
"""
a= bin(25)
print(a)
"""
#convert binary format to decimal number: 0b11001 > 25
"""
a= 0b11001
print(a)
"""
#convert decimal number to Octal format: 25 > 0o31
"""
a= oct(25) 
print(a)
"""
#convert octal format to decimal number: 0o31 > 25
"""
a= 0o31
print(a)
"""

#convert decimal number to HexaDecimal format: 25 > 0x19 , 10> 0xa
"""
a= hex(25)
print(a)
"""
"""
b= hex(10)
print(b)
"""
#convert HexaDecimal to decimal number: 0x19 > 25 , 0xa > 10
"""
a= 0x19
print(a)
"""
"""
b= 0xa
print(b)
"""

#---------------------------------------------------Swap variables-----------------------------------------


#1st  Way

"""
a= 5
b= 6

temp= a
a= b
b= temp
print(a)
print(b)
"""
#2nd Way

"""
a= 5
b= 6

a= a+b   #11
b= a-b   #5
a= a-b   #6

print(a)
print(b)
"""

#3rd Way
#Method: (^) XOR
"""
a= 5
b= 6

a= a ^ b
b= a ^ b
a= a ^ b

print(a)
print(b)
"""
#4th Way
#Method: ROT_TWO()
"""
a= 5
b= 6

a,b = b,a

print(a)
print(b)
"""

#---------------------------------------------------Bitwise Opertors in python------------------------------------------------
#compliment opertor (~)
#And (&)
#Or (|)
#XOR (^)
#Left shift (<<)
#Right shift (>>)

#---------Compliment opertors(~)
#Compliment opertors simply reverse the number 1>0 | 0>1

"""
print(~12)

#Output: (-13)
"""
#-------And (&) operator
"""
print(12 & 13)

#Output: (12)
"""
#-------Or (|) operator
"""
print(12 | 13)

#Output: (13)
"""
#-------XOR (^) operator
"""
print(12 ^ 13)

#Output: (1)
"""
#--------Left shift (<<) opertor
"""
print(10 << 2)

#Output: (40)
"""

#--------Right shift (>>) opertor
"""
print(10 >> 2)

#Output: (2)
"""


#------------------------------Import math function in python------------------------------------

#import math

"""
x= math.sqrt(25)
print(x)
"""

#--Floor & Ceil function
"""
x= math.floor(2.4)
print(x)

y= math.ceil(2.5)
print(y)
"""
#Power of -- function
"""
n= 5**2
print(n)
#or
a= pow(5,2)
print(a)
"""
#Find value of Pi
"""
print(math.pi)
"""
#find epsilon
"""
print(math.e)
"""

#Importing math as m
"""
import math as m

a= m.sqrt(25)
print(a)
"""
#importing specific module from math
"""
from math import sqrt,pow

a= sqrt(25)
print(a)

b= pow(5,2)
print(b)
"""
#Research more fucntion of math...
"""
import math
help(math)
"""

#---------------------------------------User Input in python------------------------------------------------------------
"""
x= int(input("Enter first Number"))
y= int(input("Enter Second Number"))
z= x+y
print(z)
"""
#Fetching specific input
"""
a=(input("Enter your Name"))
print(a[0])
"""
"""
a=(input("Enter your Name"))[0]
print(a)
"""
#Evaluating Expresion (like:7+4-2)
"""
a= eval(input("Enter your expression"))
print(a)
"""

#-------------------------------------if,else statement-----------------------------------------------------------------
#if
#if else
#if elif
#nested if
#-----------------

#if Statement
"""
if True:
    print("It's true")
print("By")
"""
"""
x= 10
y= x%2
if y==0:
    print("it's Even Number")
"""

#if else statement
"""
x= 9
y= x%2
if y==0:
    print("it's Even Number")
else:
    print("It's Odd Number")
"""
#nested if (means: if inside if)
"""
x= 10
y= x%2
if y==0:
    print("it's Even Number")
    if y<5:
        print("It's greater")
else:
    print("It's Odd Number")
"""
#or

"""
x= 2
y= x%2
if y==0:
    print("it's Even Number")
    if y>5:
        print("It's greater")
    else:
        print("Not so great")
else:
    print("It's Odd Number")

"""

#if elif statement
"""
x= 2

if x==1:
    print("One")
elif x==2:
    print("Two")
elif x==3:
    print("Three")
elif x==4:
    print("Four")
else:print("Over Limit")
"""

#---------------------------------------------------While loop----------------------------------------------------------
#while loop
#nested while loop
#----------------------

#while loop
"""
x= 1        #initialization
while x<=5:    #condition
    print("Hello world")
    x= x+1    #'Increment'/Decrement
"""
#or
"""
x= 5
while x>=1:
    print("Hello world")
    x= x-1
"""
#nested while loop (means: while loop inside while loop)
"""
x= 1
while x<=5:
    print("Hello ", end="")
    y= 1
    while y<=5:
        print("World ",end="")
        y= y+1

    x= x+1
    print()
"""

#--------------------------------------------For loop-------------------------------------------------------------------
"""
x= ["pintwo", 3, 4.1]

for i in x:
    print(i)
"""
#or
"""
x= "pintwo"

for i in x:
    print(i)
"""
#or
"""
for i in ["pintoo",5,6.3]:
    print(i)
"""
#or
"""
for i in range(1,100):
    print(i)
"""
#if inside for loop
"""
for i in range(1,11):
    if i%5!=0:
        print(i)
"""

#--------------------------------------------------Break, Continue, Pass------------------------------------------------

"""
x= int(input("How many candy do you want?"))

i= 1
while i<=x:
    print("Candy", i)
    i+=1
"""
#or
#-----Break
"""
av= 10
x= int(input("How many candy do you want?"))

i= 1
while i<=x:
    if i>av:
        print("Sorry only", av , "Candy are available")
        break
    print("Candy", i)
    i+=1

print("Okay, By")
"""

#------Continue

"""
for i in range(1,100):
    if i%3==0:
        continue
    print(i)

print("By")
"""
#or

"""
for i in range(1,100):
    if i%3==0 or i%5==0:
        continue
    print(i)

print("By")
"""
#-----pass
"""
for i in range(1,100):
    
    if i%2!=0:
        pass
    else:
        print(i)

print("By")
"""
#----------Continue vs Pass vs Break


#continue function

"""
for i in range(101):
    if i==3:
        continue    #Continue function skip given condition
                    #but it will print print other all numbers. In other word it will skip 3 (given condition) and continue all other number
    print(i)

"""

#break function

"""

for i in range(1,101):

    if i==3: #in this condition (if i==3:) and set break fuction, break function skip given condition
            #break function will stop the loop after found given function
                #in other word 1 to 100 after 3 it will not print next number from 3
        break

    print(i)
"""

#pass fuction

""" 

for i in range(100):

    if i==3:#in many scenario we have to use some function in our code, but at that time we don't want to call that fucntion
           #so, for that we use pass function it will skip those function or not execute that specific function
        pass

    print(i)

"""


#---------------------------------------------------Printing pattern in python------------------------------------------


# # # # # #
# # # # # # 
# # # # # # 
# # # # # #

"""
for i in range(4):

    for j in range(6):
        print("# ",end="")

    print()
"""

#or

#
# #
# # #
# # # #

"""
for i in range(4):
    for j in range(i+1):
        print("# ",end="")

    print()
"""
#or


# # # # 
# # # 
# # 
# 
"""
for i in range(4):

    for j in range(4-i):
        print("# ",end="")
    print()
"""


#------------------------------------------------for else-------------------------------------------------------
"""
num= [34,56,20,76,36,23]
for nums in num:
    if nums % 5==0:
        print(nums)
        break
else:
    print("Number not found!")
""" 

#-------------------------------------------------prime numbers-----------------------------------------------------

"""
num= 7
for i in range(2,num):
    if num % i == 0:
        print("Not prime")
        break
else:
    print("Prime")
"""

#----------------------------------------------------Array in python-----------------------------------------------------
"""
from array import *

#search on google for: "Python type code" or "python unicode"

val= array("i",[32,56,-4,9,8,2,3])
#val= array("I",[32,56,-4,8,2,3])

print(val)

print(val.buffer_info()) #it will print addres of array and the size
print(val.typecode)  #it will print type which we are working with right now
#val.reverse()   #it will reverse the order
#print(val[0]) #print using index value

for i in val:
    print(i)

#or

for i in range(len(val)):
    print(val[i])
#or

for i in range(5):
    print(val[i])

#for character unicode
#make sur array is imported

data= array("u",["a","r","h","f","e","i"])
print(data)


for i in data:
    print(i)

#if you don't know the "typecode"
#make sur array is imported

val= array("i",[32,56,4,9,8,2,3])

new_arr= array(val.typecode,(a for a in val)) #it will fetch value and typecode one by one from "vall" variable

print(new_arr)

#print using for loop
for i in new_arr:
    print(i)


#print using while loop

x= 0
while x<len(new_arr):
    print(new_arr[x])
    x= x+1
"""



#----------------------------------------Array taking value from user---------------------------------------------------
#search in Array
#Inserting elements in Array
#Searching for elements in Array

"""
from array import *

data= array("i",[])

#asking for the lenth of the array from user

lent= int(input("Enter the length of the Array"))

for i in range(lent):
    x= int(input("Enter the next value"))
    data.append(x)

print(data)


#Searching for elements in Array (using manual method)

val= int(input("Enter the value for search"))

k= 0
for e in data:
    if e==val:
        print(k)
        break

    k= k+1

#Searching for elements in Array (using function method)

#print(data.index(val))

"""


#-------------------------------------------Installing Numpy------------------------------------------------------------
#working with numpy
#creating array with numpy
"""
from numpy import *

#with numpy package no need to specify typecode

arr= array([32,54,67,36,98,45,73,82,97,43,65])
print(arr)

"""

#--------------------------------------------different ways of creating array in numpy--------------------------------------------

#array()
#linspace()
#logspace()
#arange()
#zeros()
#ones()


from numpy import *

"""
#array()

arr= array([36,56,34,38,67,45])
print(arr)
print(arr.dtype)
print(type(arr))
"""

#linspace()

"""
arr= linspace(0,15,5) #linspace() takes three parameters first is to start second is length & third is to break into the numbers of part
print(arr)
"""

#arange()

"""
arr= arange(0,15,5) #arange() takes three parameters first is to start second is length & third is step
print(arr)
"""

#logspace()

"""
arr= logspace(0,15,5) #logspace() takes three parameters first is to start second is length & third is to break into the numbers of part
print(arr)            #but in the logspace d/f b/w parts depends upon the log
print("%.2f"%arr[0])
"""

#Zeros()

"""
arr= zeros(5) #it will create an array of the given size or value will be 0 of every number by default
print(arr)
"""

#Ones
"""
arr= ones(5) #it will create an array of the given size or value will be 1 of every number by default
print(arr)
"""

#---------------------------------------------Copying an array in python--------------------------------------------------

#Array addition
#Aliasing
#Shallow copy
#Deep copy



from numpy import *

#More stuff with array

#Array addition
"""
arr= array([1,2,3,4,5])
arr= arr + 5
print(arr)
"""
#Addition of two array also called Vactorized Operation

"""
arr1= array([1,2,3,4,5])
arr2= array([4,1,7,3,8])

arr3 = arr1 + arr2

print(arr3)
"""

#Concatenate Two arrays
"""
arr1= array([1,2,3,4,5])
arr2= array([6,7,8,9,8,10])

arr3= (concatenate([arr1,arr2]))  #making two big array

print(arr3)
"""
"""
arr= array([1,2,3,4,5])

print(sin(arr))
print(cos(arr))
print(log(arr))
print(sqrt(arr))
print(sum(arr))
print(min(arr))
print(max(arr))
print(size(arr))
"""

#Copying an array | Aliasing
"""
arr1= ([6,4,2,9,1])

arr2= arr1

print(arr1)
print(arr2)

print(id(arr1))  #both the array having the same id, both are pointing to same address also called Aliasing
print(id(arr2))
"""
#How to create new array at d/f location | use: .view()
#or Shallow copy: simply means it copy the array but both array are still independent on each other
"""
arr1= array([6,4,2,9,5])
arr2= arr1.view()

#arr1[0]=7  #This will affect both the arrays called shallow copy
print(arr1)
print(arr2)

print(id(arr1))
print(id(arr2))
"""
#---------Deep copy
"""
arr1= array([6,4,2,9,5])
arr2= arr1.copy()

arr1[0]=7  #This will affect only one arrays called Deep copy

print(arr1)
print(arr2)

print(id(arr1))
print(id(arr2))
"""

#-------------------------------------------Working with Matrix in python--------------------------------------------------
#How to create Matrix
#Matrix Multiplication

from numpy import *

#Creating an multi-dimensional Array
"""
arr= zeros((3,4),dtype=int)  #3 is number of Row & 4 is number of Column
print(arr)
"""
#or
"""
arr1= array([

            [1,2,3],
            [4,5,6],
            [7,8,9],
            [10,11,12]

           ])

print(arr1)
"""
"""
print(arr1.dtype)  #type of an array
print(arr1.ndim)   #This will print the dimension of an array
print(len(arr1))   #This will count the numbers of Row
print(arr1.shape)  #This will print the numbers of Row & Column
print(arr1.size)   #This will print the size/elements of entire block
"""
# Creating an single-dimensional array from multi-dimensional array
"""
arr2= arr1.flatten()
print(arr2)
"""

# Creating an Multi-dimensional array from single-dimensional array
"""
arr3= array([ 1,2,3,4,5,6,7,8,9,10,11,12])

arr4= arr3.reshape(3,4)
print(arr4)
"""
#Creating an big 3 dimensional array in which have 2 dimensional array with each have 3 values
"""
arr4= array([
    [ 1,2,3,4,5,6],
    [7,8,9,10,11,12]
            ])

arr5= arr4.flatten()
arr6= arr5.reshape(2,2,3)
print(arr6)
"""

#Matrices Concept: you can imagine two domensional array which has multiple rows and column
#Row Matrix:single row and multiple column
#Column Matrix: Single column and multiple rows

#Creating an Matrix
"""
arr4= array([
                [ 1,2,3,4],
                [5,6,7,8]
            ])

m= matrix(arr4)
print(m)
"""
#or
"""
m= matrix("1 2 3; 4 5 6; 7 8 9")  #To seprate [] the column simply put semi colon ;
print(m)

print(diagonal(m)) #diagonal functional print only diagonal numbers(shape)which is [1 6 11] not the entire matrix
print(m.min())  #This will print the min values
print(m.max())  #This will print the max values
"""

#Adding, Multyplying Matrices

m1= matrix("1 2 3; 4 5 6; 7 8 9")
m2= matrix("1 2 3; 4 5 6; 7 8 9")
m3= m1+m2  #Adding two Matrix
m4= m1 * m2 #Myltiplying two Matrices: This is not simple multiplication; Matrices Multiplication Theory: https://goo.gl/omPVAS
print(m3)
print(m4)

#---------------------------------Functions in  python---------------------------------------------------------------
#What is function?  : Function is a block where you have one task
#Why function?     :You can create seprate function for seprate tast or you can also use them again & again by calling once
#Creating and calling function
"""
def greet():   #Definig function
    print("Hello")
    print("Good Morning")
"""
#greet()  #Calling function


#Addition of Two numbers
"""
def add(x,y):
    c= x+y
    print(c)

add(3,5)

"""
#Return Function

"""
def add(x,y):
    c= x+y
    return c

result= add(3,5)

print(result)

"""

#Returning Two Values
"""
def add_sub(x,y):
    a= x+y
    s= x-y
    return a,s

result1,result2 = add_sub(5,4)
print(result1,result2)

"""

#--------------------------------------------------------Functions Arguments in python-------------------------------------------------
#Mutable and Imutable arguments
#This concept is not in python but in other languages: Pass by Value(Means by value) or Pass by reference (Means pass by address)

"""
def update(x):
    x= 8
    print(x)

update(10)

"""
#or

"""
def update(x):
    #print("x:", id(x))
    x= 8
    #print("x2:", id(x))
    print("x: ", x)

a=10
#print("a:", id(a))
update(a)
#print("a: ", a)

"""

#or


"""
def update(lst):
    print("lst1:", id(lst))
    lst[1]= 10
    print("lst2:", id(lst))
    print("x: ", lst)

lst= [5,6,7,8,9]
print("lst0:", id(lst))
update(lst)
print("lst: ", lst)

"""

#------------------------------------------------Types of Arguments----------------------------------------------------------
#position
#keyword
#Default
#Variable Length

"""
def add(a,b):  #the accepting/Defining arguments also called as "Formal Arguments"
    ad= a+b
    print(ad)


add(5,7)    #the passing/Calling arguments also  called as "Actual Arguments"
            #The "Actual Arguments" itself has 4 Types Arguments
            #(1) position
            #(2) keyword
            #(3) Default
            #(4) Variable Length
"""

#Position Arguments

"""
def person(name,age):
    print(name)
    print(age-5)


person(age=17,name="keshav")  #When you don't know the sequence of passing & Accepting Arguments put the variable name called "keywords"
                              #or "keyword Arguments"

"""

#Default Arguments
"""
def person(name, age=17): #if the actual argument is not passing, you can define here by "Default Argument"
    print(name)
    print(age)

person("keshava")
#person("keshav",20) #if you have given "default argument" and also passing "actual argument"
                      #then the "actual argument" will override the "default argument"

"""


#Variable Length Arguments : (you can define the function where the numbers of actual argumnts is not fixed)
"""
def sum(a,*b):  #The first argument is to confirm that we will have atleast two arguments and the second arguments length is not confirm
    c= a
    for i in b:
        c= c+i
    print(c)

sum(3,5,7,4,2)

"""
#or
"""
def sum(*b):
    c= 0
    for i in b:
        c= c+i
    print(c)

sum(3,5,7,4,2)

"""

#-------------------------------------------Keyworded Variable Length Arguments in Python / **kwargs---------------------------

"""
def person(name, **data):  #** means you are passing multiple arguments with the help of keywords
    print(name)            #this is similar to Variable Length Arguments but the d/f is that
                           #in Variable Length Arguments you can not pass value with keywords but here you can
  
    for i,j in data.items(): #i for keywords and j for values
        print(i,j)

person("keshav", age= 17, state= "Delhi", number= 7827602234)

"""

#------------------------------------------Global Keyword in python-------------------------------------------------
#Global vs Local
#global a
#globals()["a"]


#-----Global or Local variable
"""
a= 10    #Global Variable (Available for entire region called "Global Scope") same vriable can be use inside function

def something():
    a= 15      #Local Variable : this variable can't use outside of the function (only available for inside function called "Local Scope")
    print("Local",a)


print("Global",a)
something()

"""
#------global a--------------
"""
a= 10

def something():
    global a       #if you wanted to change Local to Global variable then specify it with global keyword
    a= 15
    print("in function",a)

something()

print("outside",a)

"""
#-----------globals a-------------------

"""
a= 10
print("a",id(a))

def something():
    a= 9
                          #If you want local variable "a" and access of global also wanted to change the global variable
    x= globals()["a"]     #this will access the global variable "a"
    print("x",id(x))
    print("in function",a)

    globals()["a"]=15 #this will change the value of global variable "a" without affecting local variable "a" which is accessed in "x" variable

something()

print("outside",a)

"""

#-----------------------------------------------Pass List to a Function in python--------------------------------------------------------
#Count number of a Even and Odd
#Numbers in a List

def count(lst):
    odd= 0
    even= 0

    for i in lst:
        if i%2==0:
            even+=1
        else:
            odd+=1

    return even,odd


lst= [20,25,14,19,16,24,28,47,26]
even, odd= count(lst)
#print(even)
#print(odd)

print("Even: {} Odd: {}".format(even,odd))


#-----------------------------------------Fibonacci Sequence in python-------------------------------------------------------------
# Fibonacci Sequence: [0] [1] [1] [2] [3] [5] [8] [13] [21]
#Making Fibonacci Sequence in python
"""
def fib(n):

    a= 0
    b= 1

    print(a)
    print(b)

    for i in range(2,n):

        c= a + b
        a= b
        b= c
        print(c)


fib(5)

"""
#or
"""
def fib(n):

    a= 0
    b= 1

    if n==1:       #if you only want first fibonacci number
        print(n)
    else:

        print(a)
        print(b)

        for i in range(2,n):

            c= a + b
            a= b
            b= c
            print(c)


fib(1)
"""


#---------------------------------------Factorial of a number in python-------------------------------------------------
#5!= 5*4*3*2*1 or 5!= 1*2*3*4*5 | (5!= 120, 4!= 24)
"""
def fact(n):

    f= 1

    for i in range(1,n+1):

        f= f*i

    return f

x= 5
result= fact(x)
print(result)
"""

#----------------------------------------Recursion in python---------------------------------------------------------
#Recursion: simply means calling a function itself

"""
def greet():
    print("Hello")
    greet()     #this is calling itself called Recurion
                #this will print 1k times [technically infinite times] and stop with error exceed limit

greet()

"""
#or
"""
import sys

sys.setrecursionlimit(2000)  #if you wanted to set the limit of recursion
print(sys.getrecursionlimit()) #if you wanted to know recurion limit

i = 0
def greet():

    global i
    i= i+1    #counter: this will show how many time recurion has printed/(greet())
    print("Hello",i)
    greet()
    
greet()

"""


#---------------------------------------Factorial using Recursion--------------------------------------------------------
#finding Factorial of a number using Recursion
"""
def fact(n):

    if n==0:
        return 1

    return n * fact(n-1)


result= fact(5)
print(result)

"""

#--------------------------------------------------Anonymous Functions | Lambda-------------------------------------------
#Anonymous Functions or Lambda:  Function without name
#We can define function without name with the help of lambda function/expression
#this comes into picture when you wants to use function only ones and don't wants to define name of function
"""
f= lambda a : a*a

result= f(5)
print(result)
"""
#How to add two number using lambda

"""
add= lambda a,b : a+b

result= add(3,5)
print(result)
"""


#-------------------------------------------filter() | map() | reduce()------------------------------------------------------

#------filter()
#this function is used to filter out the elements of an iterabe/sequence depending on a function that tests each element in the sequence
   #to be true or not
#it return those elements of sequence, for which function is true


"""
def is_even(n):
    return n%2==0

nums= [2,3,6,8,4,6,2,9]

evens= list(filter(is_even,nums)) #filter will takes two arguments, first is your function where you the mention logic 
                                   # or second is your list/sequence/iterable
print(evens)

"""
#or  reduce number of line
"""
nums= [2,3,6,8,4,6,2,9]

is_even= lambda a : a%2==0

evens= list(filter(is_even,nums))

print(evens)

"""
#or

"""
nums= [2,3,6,8,4,6,2,9]
evens= list(filter(lambda a : a%2==0,nums))
print(evens)

"""
#-------map()
#this function excutes a specified function on each element of the iterable/sequence and perhaps change the elements 
#or
#whenever you want to change the every value, there map() function comes into the picture !

"""
nums= [2,3,6,8,4,6,2,9]

doubles= list(map(lambda a : a*2, nums))   #this will multiple the each value to 2

print(doubles)

"""
#----reduce()
#this function is used to reduce a sequence of elements to a single value by processing the elements according 
  #to a function supplied. it returns a single value
  
#this function is a part of functools module so you have to import it before using


"""
from functools import  reduce 
#reduce function is not inbuilt to use it, import it


#def add_all(a,b):
    #return a+b    #instead of using this function  use lambda function 


nums= [2,3,6,8,4,6,2,9]

sum= reduce(lambda a,b : a+b,nums)

print(sum)
"""

#filter(),map(),reduce() "ek saath"
"""
nums= [2,3,6,8,4,6,2,9]

evens= list(filter(lambda a : a%2==0,nums)) #this will filter the even number
print(evens)

doubles= list(map(lambda a : a*2, evens)) #this will multiply the number to 2 
print(doubles)

from functools import reduce
sum= reduce(lambda a,b : a+b,doubles)   #this will add the all numbers
print(sum)

"""

#---------------------------------------------Decorators in python-----------------------------------------------------
#using decorators you can add extra features to existing function

"""
def div(a,b):
    print(a/b)

div(2,5) 
"""
#i want to make numerator should always be greater then denomenetor (look below "swap")

"""
def div(a,b):

    if a<b:
        a,b = b,a

    print(a/b)

div(2,5)

"""

#continue...

"""
def div(a,b):

    if a<b:         #imagine, this division function is not with you, its's in some other file
        a,b = b,a   #or maybe you don't have an access of the code or you don't want to change the code
                    #of the existing function
    print(a/b)
                    #and we wanted to swap these two variables without touching "div function" (look below)
div(2,5)            #so here, "Decorators" comes into the picture 
                    #Decorators: using decorators you can add extra features to existing function
"""
"""
def div(a,b):
    print(a/b)

def smart_div(func):   #this will be decorator for "div", or except div function as func as i have mentioned

    def inner(a,b):   #this inner function will take same number of parameter as taken by 'div' function,
                       #name should be same it's not compulsory
        if a<b:
            a,b = b,a
        return func(a,b)

    return inner

div1= smart_div(div)
div1(2,4)
"""


#--------------------------------------------------Modules in python----------------------------------------------------
#Making our own module in seprate file (Module_Calc) and use them by importing


"""
import Module_Calc  
                
a= 2
b= 4

add= Module_Calc.addition(a,b)
print(add)
subt= Module_Calc.subtraction(a,b)
print(subt)
"""
#or

"""
from Module_Calc import addition

a= 2
b= 4
add= addition(a,b)
print(add)
"""
#or

"""
from Module_Calc import *

a= 2
b= 4

add= addition(a,b)
print(add)

subt= subtraction(a,b)
print(subt)
"""

#---------------------------------------------------Special Variable __name__--------------------------------------------
#codes are linked with Module_Calc file

"""
print(__name__) #output: __main__ | the first module name is always main because that's the point of execution
                                     #that's where codes start
"""

#1

"""
import Module_Calc     #when you import module file, everything which is in module file
                       # come to where it has imported including print statement

print("module_calc says" + __name__)

"""

#2

"""
print("Hello")       #i wanted to welcome the user when they run this first file
print("Welcome user") #but when i import this module in other file and run that so there this code will welcome for in second file
                       #i don't wanted this so we will put condition (there below :))
"""

#3

"""
def main():
    print("Hello")
    print("Welcome user")

if __name__ == "__main__":
    main()
"""


#------------------------------------------------Special Variable __name__ | part-2 ------------------------------------
#step1
"""
def fun1():
    print("from fun1")

def fun2():
    print("from func2")

def main():
    fun1()
    fun2()

main()
"""

#step2
"""
from Module_Calc import add    #1

def fun1():
    add()
    print("from fun1")

def fun2():
    print("from func2")

def main():
    fun1()
    fun2()

main()
"""

#------------------------------------Object Oriented Programming (oops)| Introduction-----------------------------------
# oops concept in easy: (https://www.programiz.com/python-programming/object-oriented-programming)

#Python supports three types of Programming paradigms(Paradigms: Paradigm can also be termed as a method to solve some
                                                        # problems or do some tasks. A programming paradigm is an approach
                                                        # to solve the problem using some programming language)
#learn paradigms in python: (https://www.geeksforgeeks.org/programming-paradigms-in-python/)

#1- Procedure Oriented programming paradigms

    #(series of computational steps are divided modules which means that the code
    #is grouped in functions and the code is serially executed step by step)
    #or
    #if you wanted to create software, you will break down your
    #projects into small small parts and those module will be function

#2- Functional programming paradigms

    #It uses the mathematical function and treats every statement as functional
    #expression as an expression is executed to produce a value. Lambda functions or
    #Recursion are basic approaches used for its implementation. The paradigms mainly
    #focus on “what to solve” rather than “how to solve”.
    #or
    #means you can achive a certain task implementing function as a mathematical function, where
    #you not manupulate data, which is, instance chaning your data you will still acomplish a task
    #one of the way is ex. pass a function to a function

#3- Object Oriented programming paradigms

    #Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects",
    #which can contain data and code: data in the form of fields (often known as attributes or properties),
    #and code, in the form of procedures (often known as methods)

    #every object will have two things:
    #1- Attribute: imagine as a data/property (ex. for huuman his name,age,height, etc)
    #2- behaviour: attribute which we know, our action defines our behaviour (ex. talking, running, dancing etc)

    #if you want to store something in object you need to define variables
    #if you wants to define behaviour you needs to methods (functions on oop is methods)

   # in oop have so many concepts like: objects, class, encapsulation, abstract, polymorphism,inheritance


#-----------------------------------------------------Class and objects-------------------------------------------------

#if you want to create object (tower) you need to blueprint (architect map) of it, here your blueprint is class
  #so, if you want boject you need to class of it

#Class - Design
#Object - Instance

"""
class computer:

    def config(self):    #behaviour (methods [function])  |  self is object which you are passing while calling
        print("i5, 16Gb, 1TB")


comp1= computer()      #"comp1" is an object of "class computer"
#print(type(comp1))

computer.config(comp1)      #calling...
"""

#or | another way of calling...
"""
class computer:

    def config(self):
        print("i5, 16Gb, 1TB")


comp1= computer()

#computer.config(comp1)

comp1.config()   # how it look behind: comp1.config(comp1)
"""

#or
"""
class computer:

    def config(self):
        print("i5, 16Gb, 1TB")


comp1= computer()
comp2= computer()

computer.config(comp1)
computer.config(comp2)

comp1.config()
comp2.config()
"""

#---------------------------------------------------__init__method------------------------------------------------------
#Special variable "__init__"  this is like function but here we call it "method"
"""
class computer():

    def __init__(self):    #this will call automatically (if object is created of its class)
        print("In init")

    def config(self):
        print("i3", "16Gb", "1TB")  #this will not call untill you not call it

comp1= computer()    #called object creation (computer())
"""

#or | let's build computer!

"""
class computer():

    def __init__(self,cpu, ram):    #  self = comp1 (the object) and other 2 parameter is which is excepting below ("i5" or 16)
        self.cpu= cpu
        self.ram= ram

    def config(self):
        print("config is ", self.cpu, self.ram)

comp1= computer("i5", 16)
comp2= computer("Rayzen3", 8)

comp1.config()
comp2.config()
"""

#-----------------------------------------------Constaructor, self and comparing objects--------------------------------

#----constructor
"""
class computer():
    pass  #we can't keep blank this area so just pass

                     #In our computer there is space called "Heap Memory" where where all the objects are stored

comp1= computer()   #every time you craete an object it is allocated to new space
comp2= computer()
                    #okay, size of an object? : Depends on the no. variables and size of each variable
                    #who allocates size to objects? | who is responsibble to assign the meamory or to calculate the memory?
                    #that's where "constructor" comes into the picture
print(id(comp1))
print(id(comp2))
"""

#-----------self | importance

"""
class computer():

    def __init__(self):
        self.name= "keshav"
        self.age= 17

comp1= computer()
comp2= computer()
  
  #both the object printing same data i wanted to update or change the data (below)

print(comp1.name, comp1.age)
print(comp2.name, comp2.age)
"""

#cotinue...

"""
class computer():

    def __init__(self):
        self.name = "keshav"
        self.age = 17

comp1 = computer()
comp2 = computer()

comp2.name= "Pintwo"
comp2.age= 16

print(comp1.name, comp1.age)
print(comp2.name, comp2.age)
"""

#continue...
"""
class computer():

    def __init__(self):
        self.name = "keshav"
        self.age = 17

    def update(self):
        self.name= "pintoo"
        self.age= 18

comp1 = computer()
comp2 = computer()

comp2.name= "Pintwo"
comp2.age= 16

comp2.update()    #or you can also change the values by defining method/function | if you have many obj you can cahnge it 
                  #by refering the obj name and .update() function

print(comp1.name, comp1.age)
print(comp2.name, comp2.age)
"""

#------------comparing  | what if i wanted to comapre two objects?


class computer():

    def __init__(self):
        self.name = "keshav"
        self.age = 17

    def update(self):
        self.name= "pintoo"
        self.age= 18

    #parameters to compare two objects | comparing age
    def compare(self,other):   # Self=comp1, other_age=comp2 | compare(who is calling, whom to compare )
        if self.age == other.age:
            return True
        else:
            return False

comp1 = computer()
comp2 = computer()

comp2.update()

#comparing two objects

if comp1.compare(comp2):

    print("They are same")
else:
    print("They are Different")


print(comp1.name, comp1.age)
print(comp2.name, comp2.age)

#----------------------------------------------Types of variales in python (oops)------------------------------------------------
#there are two types of variables in oops:
#1- Instance variables:
#2- Class/static Variables:

"""
class car():

    wheels= 4          #variables outside '__init__' and inside the class called as 'class variables' | this is common for all objects

    def __init__(self):
        self.mil= 10       #variables inside __init__ called as 'instance varable'
        self.comp= "BMW"   #these two variables are instance variables bcz as the objects changes value also change


c1= car()
c2= car()

c1.mil= 8 #changing value of 'instance variable' which will affect the single object

car.wheels= 5  #changing value for 'class variable' which affect the value of all objects

print(c1.mil,c1.comp,c1.wheels)
print(c2.mil,c2.comp,c2.wheels)

#things to remember: namespace ia an area where you can create or store objects/variable
#               -class namespace
#               -object/instance namespace
"""

#---------------------------------------------------types of Methods---------------------------------------------------
#1- instance methods
#2- class methods
#3- static method



#let us make simple function (contain: sudents, schl, marks, and average )
"""
class student():

    schl= "Yadava School"

    def __init__(self,m1,m2,m3):
        self.m1= m1
        self.m2= m2
        self.m3= m3


#finding average of numbers | funcion will return the method of finding average
    def avg(self):
        return (self.m1+ self.m2+ self.m3)/3


s1= student(34,47,32)
s2= student(89,32,12)

print(s1.avg())
print(s2.avg())
"""

#-----------------instance methods

#the instance methods contains two type itself
#1- Accessor
#2- Mutattor
"""
class student():

    schl= "Yadava School"

    def __init__(self,m1,m2,m3):
        self.m1= m1
        self.m2= m2
        self.m3= m3

    def avg(self):
        return (self.m1+ self.m2+ self.m3)/3

    def get_m1(self):    #if you are only fatching the value of instance variable called as 'Accessor'
        return self.m1    #if you are modifying the value of instance variable called as 'Mutattor'

    def set_m1(self,value):
        self.m1= value


s1= student(34,47,32)
s2= student(89,32,12)

print(s1.avg())
print(s2.avg())
"""

#------class methods
"""
class student():

    schl= "Yadava School"

    def __init__(self,m1,m2,m3):
        self.m1= m1
        self.m2= m2
        self.m3= m3

    def avg(self):
        return (self.m1+ self.m2+ self.m3)/3

    @classmethod #if you want to create class method you need to declare @classmethod called as 'Decorator'
    def info(cls): #if you wanted to work with class variables use 'cls' keyword nothing else| cls for class and self keyword for instance var
        return cls.schl

s1= student(34,47,32)
s2= student(89,32,12)

print(s1.avg())
print(s2.avg())

print(s1.info()) #i wanted to work info() with all students/obj not particular to single one (below :))
print(student.info())
"""

#------static method
#if you want any method which has nothing to do with instance and class variable
#if you wanted to do something extra which is not concern with the variable at that time you will be use 'static method'
"""
class student():

    schl= "Yadava School"

    def __init__(self,m1,m2,m3):
        self.m1= m1
        self.m2= m2
        self.m3= m3

    def avg(self):
        return (self.m1+ self.m2+ self.m3)/3

    @classmethod
    def get_schl_name(cls):
        return cls.schl

    @staticmethod  #if you want to create static method you need to declare @staticmethod called as 'Decorator'
    def info():    #if you want any method which has nothing to do with instance and class variable. don't pass anything no self or cls keyword
        print("This is an example of static method")

s1= student(34,47,32)
s2= student(89,32,12)

print(s1.avg())
print(s2.avg())

print(student.get_schl_name())

student.info()
"""

#-----------------------------------------inner class | class inside class-----------------------------------------------

"""
class student:

    def __init__(self,name,rollno):
        self.name= name
        self.rollno= rollno


s1= student("keshav", 17)
s2= student("satyam", 18)

print(s1.name, s1.rollno) #instead printing in this way we can define function which will do the same thing (below :))
"""
#or

"""
class student:

    def __init__(self,name,rollno):
        self.name= name
        self.rollno= rollno

    def show(self):
        print(self.name,self.rollno)


s1= student("keshav", 17)
s2= student("satyam", 18)

s1.show()
s2.show()
"""
#or

"""
class student:

    def __init__(self,name,rollno):
        self.name= name
        self.rollno= rollno

        self.lap= self.laptop()  #obj of inner class laptop inside the outer class

    def show(self):
        print(self.name,self.rollno)

    class laptop:     #class inside the class | inner class

        def __init__(self):
            self.brand= "Hp"
            self.cpu= "i5"
            self.ram= 8


s1= student("keshav", 17)
s2= student("satyam", 18)

s1.show()
s2.show()

lap1= s1.lap
lap2= s2.lap

print(id(lap1))
print(id(lap2))

#lap_oj= student.laptop #[duplicate] obj of inner class laptop outside the class

"""
#continue... printing of above code with the help of show function

"""
class student:

    def __init__(self,name,rollno):
        self.name= name
        self.rollno= rollno

        self.lap= self.laptop()

    def show(self):
        print(self.name,self.rollno)

        self.lap.show() #...

    class laptop:

        def __init__(self):
            self.brand= "Hp"
            self.cpu= "i5"
            self.ram= 8

        def show(self):  #...
            print(self.brand,self.cpu,self.ram)


s1= student("keshav", 17)
s2= student("satyam", 18)

s1.show()
s2.show()

lap1= s1.lap
lap2= s2.lap

print(id(lap1))
print(id(lap2))

#lap_oj= student.laptop #[duplicate] obj of inner class laptop outside the class

lap1.show()  #...
"""

#------------------------------------------------inheritance in python--------------------------------------------------
#using features of existing class
#parents,child, property 'inheritance' concept
"""
class A():

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

a1= A()

a1.feature1()
a1.feature2()
"""

#continue... adding more feature/method
"""
class A():

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B():

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

a1= A()

a1.feature1()
a1.feature2()

b1= B() #in B ojb having only two function i also wanted the existing and new added function/method 
        #that's where inheritence comes in to picture
b1.feature3()
b1.feature4()
"""

#continue... inheritence

"""
class A():   #supper cls or parent cls

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B(A): #cls B is child/sub class of cls A | cls B is inheriting all the feature of cls A | sub cls or child cls
            #single level inheritence

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

a1= A()

a1.feature1()
a1.feature2()

b1= B()
b1.feature3()
b1.feature4()
b1.feature1()
b1.feature2()
"""

#continue... multilevel inheritence
"""
class A():   #supper cls or parent cls

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B(A):

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

class C(B): #this grand parent or multilevel cls have all the features of previous cls

    def feature5(self):
        print("feature 5 is working")

    def feature6(self):
        print("feature 6 is working")

a1= A()

a1.feature1()
a1.feature2()

b1= B()

b1.feature3()
b1.feature4()
b1.feature1()
b1.feature2()

c1= C()

c1.feature1()
c1.feature2()
c1.feature3()
c1.feature4()
c1.feature5()
c1.feature6()
"""
#continue... multiple inheritence

"""
class A():   #supper cls or parent cls

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B():

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

class C(A,B): #cls C is now inheriting features of cls A and B | called as multiple inhertance

    def feature5(self):
        print("feature 5 is working")

    def feature6(self):
        print("feature 6 is working")

a1= A()

a1.feature1()
a1.feature2()

b1= B()

b1.feature3()
b1.feature4()

c1= C()

c1.feature1()
c1.feature2()
c1.feature3()
c1.feature4()
c1.feature5()
c1.feature6()
"""

#---------------------------------------------constructor in inheritance------------------------------------------------
#Constructor in Inheritance
#Method Rresolution Order (MRO)

"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B(A):  #inhering cls A in B

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

a1= A() #this obj have __init__  method
b1= B() #this will inherite __init__ feature along with cls A feature? | ans. yss
"""
#continue...
"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B(A):   #now both the class have __init__ method

    def __init__(self):
        print("in B init")

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

a1= A()   #if you create obj of sub cls it will first try to find init of sub cls
b1= B()    #if it is not found then it will init method of super cls
"""
#continue... what if i wanted init method of both the cls
"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B(A):

    def __init__(self):
        super().__init__() #this will inherite all the features of cls A in B along with inint of sub cls
        print("in B init")

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

a1= A()  #when you create the obj of sub cls it will call init of sub cls firts
b1= B()   #if you have call super cls then it will first call init of super cls then call init of sub cls
"""
#continue...

"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")

class B():

    def __init__(self):
        print("in B init")

    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

class C(A,B):  #inheriting A and B in cls C | but what about init?, init will get call from first left to right side

    def __init__(self):
        super().__init__()
        print("in C init")

    def feature5(self):
        print("feature 5 is working")

    def feature6(self):
        print("feature 6 is working")

c1= C()
"""
#continue...
"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1-A is working")

    def feature2(self):
        print("feature 2 is working")

class B():

    def __init__(self):
        print("in B init")

    def feature1(self):
        print("feature 1-B is working")

    def feature4(self):
        print("feature 4 is working")

class C(A,B):

    def __init__(self):
        super().__init__()
        print("in C init")

a1= C()
a1.feature1() #calling obj of cls C having inheritance of A,B but which cls of featured1 will get called? cls A or cls B?
              #ans: cls A, bcz first will get from left | also called 'Method Rresolution Order (MRO)'
"""

#continue...
#you can also use super() to call other method/function as well not just init
"""
class A():

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature 1-A is working")

    def feature2(self):
        print("feature 2 is working")

class B():

    def __init__(self):
        print("in B init")

    def feature1(self):
        print("feature 1-B is working")

    def feature4(self):
        print("feature 4 is working")

class C(A,B):

    def __init__(self):
        super().__init__()
        print("in C init")

    def feat(self):
        super().feature2()  #you can also use super() to call other method/function as well not just init

a1= C()
a1.feature1()
a1.feature2()
"""


#-------------------------------------------------polymorphism in python Theory (introduction)----------------------------------------------------------
#poly morph ism
#poly means: many
#morph means: form  | so, that the one things can take multyple forms or the one thing wgich will behave in d/f way
#As human we have d/f forms, as the situation changes we change ourself,
#ex. we behave d/f in office and we behave d/f when we are with our frnds
#------
#this concept use a lot when it comes to like:
#loose coupling, dependency injection, interface and etc
#-----
#there are four way of implementing polymorphism
#1- Duck typing
#2- Operator Overloading
#3- Method Overloading
#4- Method Overriding


#------------------------------------------------Duck typing------------------------------------------------------------

#Duck Test:
#if it looks like a duck, swim like a duck , and quack like a duck, then it probably is a duck. :)


#small example (Concept): Dynamic Typing
"""
x= 5  #type is interger of 'x'
x= "Keshav"  #and now defining type of 'x' string
"""
#there is no any 'type' of 'x' untill you not define it, 'x' is just a name to it, not have any specific type to 'x', untill you do.

#Dynamic Typing: simply means the type which you will mention later

#-------------
"""
class PyCharm():   #2...

    def execute(self):
        print("Compilling")
        print("Running")

class MyEdittor():   #6...

    def execute(self):
        print("Compilling")
        print("Running")
        print("Spell check")
        print("Debugg v2")

class laptop():    #1...

    def code(self,ide):
        ide.execute() #it doesn't matter which 'ide' you are passing, only should have is the 'execute method' to it


#ide= PyCharm() #obj of PyCharm ide | 4...

ide= MyEdittor()  #obj of MyEdittor ide | 7...

lap1= laptop()  #3...
lap1.code(ide)  #5...

#and there is the case: looks like a duck, swim like a duck , and quack like a duck, then it probably is a duck
#in the same way: if there is an obj (which is 'ide') and it has method 'execute' that it, we are not concern about which
#cls obj it is, we are concer about it should have execute method | called as Duck Typing
"""

#-----------------------------------------------Operator Overloading| Polymorphism--------------------------------------

"""
#can we add int and str?

a= 5
b= "Keshav"

print(a + b)  #ofcourse not in this way!

#all this things are predefined | called as synthetic sugar

"""
#-----
"""
#adding two int using inbuilt method
a= 5
b= 6

print(a+b)

print(int.__add__(a,b))   #press control and click on int function to see it's cls and methods
"""
#------


#adding two str using inbuilt method (concatenate two str)
"""
a= "5"
b= "6"

print(a+b)

print(str.__add__(a,b))  #press control and click on str function to see it's cls and methods
"""

#so, to point to remember is: when you mention (+) it calls __add__ method or (-) it call __sub__ method and same goes on
#these things are called as 'Magic Method'

#------Operator Overloading
"""
class student():

    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2

s1= student(58,69)
s2= student(60,65)

#i wanted to add this two students

s3= s1 + s2  #-> something like this | but it will not work here as it is here! (below :))
"""
#continue...

"""
class student():

    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2

#--Operator Overloading
    def __add__(self, other):
        m1= self.m1 + other.m1
        m2= self.m2 + other.m2
        s3= student(m1,m2)

        return s3

s1= student(58,69)
s2= student(60,65)

s3= s1 + s2  #-> behind the scene: student.__add__(s1,s2)

print(s3.m1)
"""
# now i wanted to compare marks of both the students

"""
class student():

    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2

    def __gt__(self, other):
        r1= self.m1 + self.m2
        r2= other.m1 + other.m2

        if r1 > r2:
            return True
        else:
            return False

s1= student(58,69)
s2= student(60,65)

if s1 > s2:
    print("s1 wins")
else:
    print("s2 wins")

#----done, now some extra!

a= 5
print(a) #-> this is print the value of 'a' not the address of it
print(s1) #-> this is printing the address of 's1'(obj) not the data or value?

print(a.__str__()) #this is how call behind the scene | you don't call it but this get call automatical by default (inbuilt)
print(s1.__str__())
"""
#---------

# i don't want address, i wanted values (below :) )

"""class student():

    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2

    def __gt__(self, other):
        r1= self.m1 + self.m2
        r2= other.m1 + other.m2

        if r1 > r2:
            return True
        else:
            return False

    def __str__(self):  #overridding __str__ method
        return self.m1,self.m2


s1= student(58,69)
s2= student(60,65)

if s1 > s2:
    print("s1 wins")
else:
    print("s2 wins")


a= 5
print(a.__str__()) 
print(s1.__str__())
"""
#or
"""
class student():

    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2

    def __gt__(self, other):
        r1= self.m1 + self.m2
        r2= other.m1 + other.m2

        if r1 > r2:
            return True
        else:
            return False

    def __str__(self):  #...
        return "{} {}".format(self.m1, self.m2)


s1= student(58,69)
s2= student(60,65)

if s1 > s2:
    print("s1 wins")
else:
    print("s2 wins")


a= 5
print(a)  #...
print(s1)

#point to remember: operator overloading which simply means you have operator like +, -, /, *, so the operator will remain same 
#but the operand will change, the type of parameters will change ex, when you call + you are calling __add__() method and 
#add method take d/f types of parameter or argument, so thats the overloading which means: you have same method name 
#but the type or number of arguments are  d/f
"""

#--------------------------------------------Method Overloading and Method Overriding------------------------------------
"""
#---Method Overloading

#if you have a class and two method name with the same name but the d/f parameter or arg
#called as method overloading
#example:
class student():
    def average(a,b):
    def average(a,b,c):
#but in python we don't have this concept so you can't create method with the same name

#---Method Overriding

#you have two methods with with the same name and same number of parameter or arg (ofcourse not in the same cls)
#we have the concept of inheritance, cls A, B both have the Method with the same name and number of parameter or arg
#this is called as Method Overriding
"""

#code time

#---------Method Overloading
"""
class student:

    def __init__(self,m1,m2):
        self.m1= m1
        self.m2= m2

    def sum(self,a,b):
        s= a + b

        return s

s1= student(65,45)

print(s1.sum(5,9,6)) #here i can't except three arg bcz i am passing only two arg (a,b) | i don't want it
"""

#continue...

"""
class student:

    def __init__(self,m1,m2):
        self.m1= m1
        self.m2= m2

    def sum(self,a=None,b=None,c=None): #even if don't pass the value it will be none | there are another way doing this (keyword variable length)

        s=0
        if a!=None and b!=None and c!=None:
            s= a + b + c
        elif a!=None and b!=None:
            s= a+b
        else:
            s= a

        return s

s1= student(65,45)

print(s1.sum(5,9))  #if i pass except value this will be replaced to None respectively
"""

#-----Method Overriding
"""
class A:
    def show(self):
        print("In A show")

class B(A):   #this is overriding show mehod of cls A 
    def show(self):
        print("In B show")


a1= B()
a1.show()
"""

#----------------------------------------Abstract Class and Abstract Method---------------------------------------------
#python doesn't support 'Abstract' cls or method by default but we have 'abc'(Abstract Base Classes) module to achieve Abstract cls
#what are Abstract cls or method? :
"""
class computer:

    def prcessor(self): #the method which has only declaration but not have defination(statement) called them 'Abstract Method'
        pass            #and the class (computer) which have Abstract Method called as 'Abstract Cls'
"""

#continue...
"""
from abc import ABC, abstractmethod  #module to achieve Abstract cls and method

class computer(ABC): #this will make the sub cls of cls ABC | Abstract cls

    @abstractmethod
    def processor(self):
        pass


comp= computer()  #this will give an error bcz we can't create obj of Abstract cls bcz we have not defined (statement) of method
comp.processor()
"""
#continue...

"""
from abc import ABC, abstractmethod

class computer(ABC):

    @abstractmethod
    def processor(self):
        pass

#...
class laptop(computer):  #even this cls of boj we can't create bcz inheriting computer cls which is Abstract cls
    pass


#comp= computer()
comp1= laptop()  #...
#comp.processor()
"""

#continue...

"""
from abc import ABC, abstractmethod

class computer(ABC):

    @abstractmethod
    def processor(self):
        pass


class laptop(computer):

    #...
    def processor(self):  # now we are defining(statement) of this method
        print("its running")


#comp= computer()
comp1= laptop()
#comp.processor()
comp1.processor()
"""

#--------------------------------------------------------iterator-------------------------------------------------------

#nums= [7,8,9,5]

"""
print(nums[1]) #here we can print the value which is on index 1
print(nums[7]) #what if i print beyond the index value | offcourse will give an error
"""
#---
"""
for i in nums: #another way of printing values | for loop
    print(i)
"""

#another way of iterating values
"""
it= iter(nums) #this will convert list (nums) into iterator
               #this iterator will give one value at a time not all the value

print(it.__next__()) #this will print one value at a time
print(it.__next__()) #this will give one value at a time but next to previous value

print(next(it))

for i in nums:  #for loop
    print(i)
"""

#creating your own iterator, which will print 1-10
"""
class TopTen:

    def __init__(self):
        self.num= 1  #counter variable

    def __iter__(self): #this will give the obj of iterator
        return self

    def __next__(self): #this will give the next value

        #this is how this will give you the next value
            val= self.num
            self.num += 1

            return val

values= TopTen()

for i in values:
    print(i)
"""
#continue...
"""
class TopTen:

    def __init__(self):
        self.num= 1 

    def __iter__(self):
        return self

    def __next__(self):

        if self.num<=10: #...1 | condition to print
            val= self.num
            self.num += 1

            return val
        else:
            raise StopIteration  #...2 |to stop the loop | exception

values= TopTen()

for i in values:
    print(i)
"""

#-----------------------------------------------Generator---------------------------------------------------------------
#generator work like iterator, here you don't need to define __iter__ and __next__

#making iterator, which will print 1-10 using generator
"""
def topten():

    yield 1 #yield behave as a return but yield return obj of iterator
            #yield is a 'generator' which will return 'iterator'

    #we can take multiple yields here

    yield 2
    yield 3
    yield 4
    yield 5

values= topten()
print(values)  #yield will return the obj

#to print the value of generator 'yield'
print(values.__next__())
print(values.__next__())

    #or

for i in values:
    print(i)
"""

# -> top ten perfect square using generator

"""
def topten():

    n= 1
    while n<=10:
        sq= n*n
        yield sq
        n= n+1    #or n+=1

values= topten()

for i in values:
    print(i)
"""

#--------------------------------------------Exception Handling---------------------------------------------------------
#Errors and Three types Error

#1 Compile time error
  #error due to spelling mistake called as syntactical errors or arror at the time of compiltion | e.g. missing colon (:), wrong spelling (prant)etc.

#2 Logical error
  #codes get compiled and giving an output but not be correct output (e.g. wrong output)

#3 Run time error
  #your code get compiled, no syntactical error, no logical error as well
  #error due to wrong input by user | mistake done by user not by you |you are dividing two number user gives input (e.g. divided by zero)
  #error during run time due to wrong input, deleted some file, issue with database or server connection

#...
"""
a= 5
b= 2
print(a/b)
#-> here we have three statement line no. 3416, 3417, 3418
#line no. 3416, 3417 called as 'normal'statement (bcz this will not give error if there values changes in future)
#and 3418 called as 'critical' statement (this can give an error)
"""
#or...
"""
a= 5
b= 0

print(a/b)

print("By")  #this stetement is not getting called due to in b/w error. i don't want it!
"""
#...
"""
a= 5
b= 0

try: #with 'try' keyword we are saying below are critical statement try to run
    print(a/b)

except Exception: #with 'except' keyword saying if there above critical statement have error or goes wrong
                  #then except exception (error) and run below statement
    print("Hey you can not not divide 5 by 0")
    #you can perform d/f operation here as well!

print("By")
"""

#what if you wanted to print error as well

"""
a= 5
b= 0

try:
    print(a/b)

except Exception as e: #here exception (error) take as 'e'
    print("Hey you can not do", e)


print("By")
"""

#continue... if you have opened resources it's good practice to closed it
#e.g. if you have opened a database make sure you are closing it before exiting
"""
a= 5
b= 0

try:
    print("resource opened") #1..
    print(a/b)
    #print("resource closed")  #not here outside exception #2..
except Exception as e:
    print("you can not do", e)
    #3...
    #print("resource closed") #this will work here only if there is any exception. what if there is not any exception to closed resource

#4...
finally: #finally block will be executed if we get exception(error) as well as if we don't get the error(exception)
    print("resource closed")
"""

#continue... d/f type of exception to except or handle

"""
a= 5
b= 0


try:
    k = int(input("Enter a number"))  # give input 'str'
    print(k)

    print("resource opened")
    print(a/b)

except ZeroDivisionError as e: #this will handle only specific exception 'ZeroDivisionError'
    print("you can not do",e)

except ValueError as e:  #this will handle only specific exception 'ValueError'
    print("Invalid input",e)

except Exception as e: #this is to handle all type of exception if there is anything goes wrong
    print("Something went wrong",e)

finally:
    print("resource closed")
"""

#--------------------------------------------------------MultiThreading-------------------------------------------------

#Thread? : A thread is a path of execution within a process. A process can contain multiple threads.
#A thread of execution is the smallest sequence of programmed instructions
#that can be managed independently by a scheduler, which is typically a part of the operating system.

#e.g. : In MS office we can write content, change the font, save in other format & etc, MS office provides you so many features
#so we can break one task into multiple process and then again we can break down those process into small-small thread
#imagine thread as a lightweight process when you break down a big task into small parts each parts will be called as threads

#--let Build our own Threads

"""class Hello:
    def run(self):
        for i in range(5):
            print("Hello")

class Hi:
    def run(self):
        for i in range(5):
            print("Hi")

t1= Hello()
t2= Hi()

t1.run()
t2.run()

#This is printing in sequence wise first 'Hello' and secondly 'Hi' for the five times 
#when it process using single core- process task sequence wise, e.g first 'hello' then 'hi' called as 'MainThread' and its by default
#i wanted 'Hello' & 'Hi' take 5 decond(1 'hello'/second, 1 'hi'/second) to print in total takes 10 second
"""
#continue...

#Creating Two threads which will called simultaneously or parallelly

"""
from threading import *   #to work with thread need's to import

class Hello(Thread):
    def run(self):
        for i in range(500):
            print("Hello")

class Hi(Thread):
    def run(self):
        for i in range(500):
            print("Hi")

t1= Hello()
t2= Hi()


t1.start() #we are definig method 'run' & calling 'start'? bcz behind the scene when we say 'start' internally
           #it will call 'run' method (bcz we do have run method inside class 'thread', (to check ctrl+ click on Thread))
t2.start()

#finally we have created two thread which will run parallelly but to fast execution not seeing expected output (collision of two thread)
#in our system have concept 'scheduler' which will give specific time to execute (slow)
"""

#continue...

"""
from time import sleep    #module to use scheduler

from threading import *

class Hello(Thread):
    def run(self):
        for i in range(5):
            print("Hello")
            sleep(1)    #scheduler

class Hi(Thread):
    def run(self):
        for i in range(5):
            print("Hi")
            sleep(1)

t1= Hello()
t2= Hi()


t1.start()
sleep(0.2) #to avoid collision
t2.start()

#so succesfully we have three threads 1. MainThread 2. t1.start 3. t2.start
"""
#continue...

"""
from time import sleep

from threading import *

class Hello(Thread):
    def run(self):
        for i in range(5):
            print("Hello")
            sleep(1)

class Hi(Thread):
    def run(self):
        for i in range(5):
            print("Hi")
            sleep(1)

t1= Hello()
t2= Hi()


t1.start()
sleep(0.2)
t2.start()

  #2...

t1.join()
t1.join()

  #1...
print("By")  #what do you think where this will get printed | ans. In b/w thread
            #to print this the MainThread is responsible so, we will ask the MainThread to execute only when
            #thread 1 & 2 is already executed (join)
"""
#-------------------------------------------------------File Handling---------------------------------------------------
#this is linked with 'KeshavDetails.txt' file

# a file named "KeshavDetails", will be opened with the reading mode
"""
f= open('KeshavDetails','r')  #first is file name which you wanted to open and second is purpose
                                #'r', for reading
                                #'w', for writing
                                #'a', for appending
                                #'r+', for both reading and writing
#print(f)

#this will print the entire content of that file
#print(f.read())

#this will print single line at a time
print(f.readline())
print(f.readline())  #this will print next line to previous one
print(f.readline(),end="") #if you don't wanted space b/w lines
print(f.readline())
print(f.readline(3)) #if you wanted only few character
"""

#write something in a file
"""
f1= open("KeshavDetails2","w") #this will create automatically a file with mentioned name
                                #if you have not created

#writing text in file
f1.write("Something Written ")
f1.write("by Keshav")  #if i delete these two lines from here, these text will be as it is in that txt file
                    #but if i delete these line and then write something then previous text will be replaced by new one
                    #but i don't wanted to delete those text which is already in that file i want to add in it more
"""
#apending
"""
#f1= open("KeshavDetails2","w") #1...

#change to 'a'
f1= open("KeshavDetails2","a")  #5...

#f1.write("Something Written ") #2...,check text, 3...delete both line, 4...run check text
#f1.write("by Keshav")

f1.write("Adding some text") #6...
"""

#fetching and storing data from one to another file
"""
f= open("KeshavDetails","r")

f1= open("KeshavDetails2","a")

for data in f:
    f1.write(data)
"""

#working with img

"""
f= open("my_pic.jpg","rb") #1...,rb: read binary bcz in img we don't have char format have numbers, pixel or binary

f1= open("keshav_pic.jpg","wb") #3...

for i in f:  #2...
    print(i)

    #3...
    f1.write(i)
"""


